#!/bin/bash

if [ x"$WARPDRIVE_DEBUG" != x"" ]; then
    set -x
fi

# This script will run 'mod_wsgi-express start-server', adding in some
# additional initial arguments to send logging to the terminal.

# Setup the environment if not already done.

if [ x"$WARPDRIVE_SCRIPT" = x"" ]; then
    . `which warpdrive-vars`
fi

WARPDRIVE_SCRIPT=start
export WARPDRIVE_SCRIPT

# Run any user supplied script to be run prior to starting the
# application in the actual container. The script must be executable in
# order to be run. It is not possible for this script to change the
# permissions so it is executable and then run it, due to some docker
# bug which results in the text file being busy. For more details see:
#
#   https://github.com/docker/docker/issues/9547

if [ -f .warpdrive/action_hooks/deploy ]; then
    if [ ! -x .warpdrive/action_hooks/deploy ]; then
        echo "WARNING: Script .warpdrive/action_hooks/deploy not executable."
    fi
fi

if [ -x .warpdrive/action_hooks/deploy ]; then
    echo " -----> Running .warpdrive/action_hooks/deploy"
    .warpdrive/action_hooks/deploy
fi

# Determine whether we have been told that we are running a specific web
# application server type. If we haven't, we will try and automatically
# determine how the server should be started and what WSGI server to use.

if [ -f .warpdrive/server_type ]; then
    WARPDRIVE_SERVER_TYPE="`cat .warpdrive/server_type`"
else
    WARPDRIVE_SERVER_TYPE="auto"
fi

# If automatic, we are going to try a number of different strategies.
# First up we are going to check whether there exists an executable
# 'app.sh' program in the top level directory of the application. If
# there is, we switch to 'shell' server type.

if [ "$WARPDRIVE_SERVER_TYPE" = "auto" -a -x app.sh ]; then
    WARPDRIVE_SERVER_TYPE="shell"
    WARPDRIVE_SERVER_ARGS="app.sh"
fi

# Now check whether there exists an 'app.py' script file in the top
# level directory. If there is, we switch to 'python' server type.

if [ "$WARPDRIVE_SERVER_TYPE" = "auto" -a -f app.py ]; then
    WARPDRIVE_SERVER_TYPE="python"
    WARPDRIVE_SERVER_ARGS="app.py"
fi

# Now check whether there exists a 'paste.ini' file. If there is, switch
# to 'mod_wsgi' server type.

if [ "$WARPDRIVE_SERVER_TYPE" = "auto" -a -f paste.ini ]; then
    WARPDRIVE_SERVER_TYPE="mod_wsgi"
    WARPDRIVE_SERVER_ARGS="--application-type paste --entry-point paste.ini"
fi

# Now check whether there exists a 'wsgi.py' file in the top level
# directory. If there is, we switch to 'mod_wsgi' server type.
#
# We also check whether there is a 'wsgi/static' directory for
# compatibility with OpenShift 2. If there is, this will be mapped as
# being a directory of static files under '/static' sub URL.

if [ "$WARPDRIVE_SERVER_TYPE" = "auto" -a -f wsgi.py ]; then
    WARPDRIVE_SERVER_TYPE="mod_wsgi"
    WARPDRIVE_SERVER_ARGS="--application-type script --entry-point wsgi.py"

    if [ -d wsgi/static ]; then
        WARPDRIVE_SERVER_ARGS="$WARPDRIVE_SERVER_ARGS --url-alias /static wsgi/static"
    fi
fi

# Now check whether there exists a 'wsgi/application' file. This was an
# older convention used by OpenShift 2. If there is, switch to
# 'mod_wsgi' server type.
#
# We also check whether there is a 'wsgi/static' directory for
# compatibility with OpenShift 2. If there is, this will be mapped as
# being a directory of static files under '/static' sub URL.

if [ "$WARPDRIVE_SERVER_TYPE" = "auto" -a -f wsgi/application ]; then
    WARPDRIVE_SERVER_TYPE="mod_wsgi"
    WARPDRIVE_SERVER_ARGS="--application-type script wsgi/application"

    if [ -d wsgi/static ]; then
        WARPDRIVE_SERVER_ARGS="$WARPDRIVE_SERVER_ARGS --url-alias /static wsgi/static"
    fi
fi

# Now check whether there exists a 'manage.py' file in the top level
# directory. This can indicate we are running Django. Validate that it
# is probably Django and then use 'manage.py' to determine the WSGI
# application entry point, static files location and mount point. Switch
# to 'mod_wsgi' server type.

if [ "$WARPDRIVE_SERVER_TYPE" = "auto" -a -f manage.py ]; then
    if grep -q DJANGO_SETTINGS_MODULE manage.py; then
        WARPDRIVE_TMPMODULE="django_settings_$$"
        WARPDRIVE_TMPSCRIPT="/tmp/server_vars_$$.py"

        python manage.py diffsettings > /tmp/$WARPDRIVE_TMPMODULE.py

        cat > $WARPDRIVE_TMPSCRIPT << !
from __future__ import print_function
import sys
sys.path.insert(0, '/tmp')

try:
    import $WARPDRIVE_TMPMODULE as settings
    wsgi_application = getattr(settings, 'WSGI_APPLICATION')
    static_url = getattr(settings, 'STATIC_URL', '/static/')
    static_root = getattr(settings, 'STATIC_ROOT', None)
    entry_point = '.'.join(wsgi_application.split('.')[:2])
    callable_object = wsgi_application.split('.')[-1]
except Exception:
    pass
else:
    options = [
        '--application-type module',
        '--entry-point %s' % entry_point,
        '--callable-object %s' % callable_object]

    if static_root:
        if static_url.endswith('/') and not static_root.endswith('/'):
            static_root = static_root + '/'
        options.append('--url-alias %s %s' % (static_url, static_root))

    print(' '.join(options), end='')
!

        WARPDRIVE_TMPOPTIONS=`python $WARPDRIVE_TMPSCRIPT`

        if [ x"$WARPDRIVE_TMPOPTIONS" != x"" ]; then
            WARPDRIVE_SERVER_TYPE="mod_wsgi"
            WARPDRIVE_SERVER_ARGS="$WARPDRIVE_TMPOPTIONS"
        fi

        rm /tmp/$WARPDRIVE_TMPMODULE.py
        rm $WARPDRIVE_TMPSCRIPT
    fi
fi

# If was doing auto detection and couldn't match any possible way to
# host the Python web application, switch to 'mod_wsgi' server type and
# show the default splash page.

if [ "$WARPDRIVE_SERVER_TYPE" = "auto" ]; then
    WARPDRIVE_SERVER_TYPE="mod_wsgi"
    WARPDRIVE_SERVER_ARGS=""
fi

# Finally, execute the startup script for the final server type.

WARPDRIVE_START=`which $0`
WARPDRIVE_ACTION_HOOKS=`dirname $WARPDRIVE_START`/../action_hooks

exec $WARPDRIVE_ACTION_HOOKS/$WARPDRIVE_SERVER_TYPE-start $WARPDRIVE_SERVER_ARGS
